{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docs Home","text":""},{"location":"#singular-genomics-docs","title":"Singular Genomics Docs","text":"<p>singulargenomics.com </p> <p>These pages provide documentation, example workflows, and helper tools for analyzing, and post-processing data generated by the G4X spatial sequencer.</p> <p></p>"},{"location":"#g4x-helpers","title":"G4X-helpers","text":""},{"location":"#post-processing-tools-and-helper-models-for-g4x-data","title":"Post-processing tools and helper models for G4X-data","text":"<p>With G4X-helpers we provide an open-source toolkit for common post-processing tasks \u2014 such as applying custom segmentations or adding your own labels to the G4X-viewer. You can access its core features from the command-line interface (CLI) and additionally import it as a standalone Python package to interact with your data.</p>"},{"location":"#in-this-section-you-can","title":"In this section, you can:","text":"<ul> <li>learn how to install G4X-helpers on your system</li> <li>get started with using the command line interface (CLI)</li> <li>find a description of its CLI features </li> </ul>"},{"location":"#g4x-viewer","title":"G4X-viewer","text":""},{"location":"#explore-and-visualize-your-g4x-data","title":"Explore and visualize your G4X-data","text":"<p>The G4X-viewer is a Python-based, multi-purpose, interactive viewer specifically designed to help you explore your G4X-data. The G4X-viewer is accessible through our website or can be downloaded from GitHub as a standalone application and hosted locally.</p>"},{"location":"#in-this-section-you-can_1","title":"In this section, you can:","text":"<ul> <li>find resources to learn how to navigate your data with the G4X-viewer</li> </ul>"},{"location":"#g4x-data","title":"G4X-data","text":""},{"location":"#reference-documentation-for-g4x-output-files","title":"Reference documentation for G4X-output files","text":"<p>The G4X produces multi-modal output containing tables, images, arrays and annotated matrices for single-cell analysis. The files found in the output directory are compatible with popular Python libraries from the <code>scverse</code> ecosystem, like <code>scanpy</code>, <code>rapids-singlecell</code>, <code>squidpy</code>, and <code>spatial-data</code>, and, if you prefer working in R, can be easily imported into <code>Seurat</code>.</p>"},{"location":"#in-this-section-you-will-find","title":"In this section, you will find:","text":"<ul> <li>details on the G4X-output files and their organization</li> <li>guides on importing G4X-data into popular analysis tools in Python and R </li> </ul>"},{"location":"#g4x-tutorials","title":"G4X-tutorials","text":""},{"location":"#get-started-analyzing-your-data","title":"Get started analyzing your data","text":"<p>G4X Tutorials are a collection of example workflows that demonstrate how to analyze G4X-data using popular Python and R libraries. These tutorials cover a wide range of topics, from basic data import and visualization to advanced analysis techniques.</p>"},{"location":"#in-this-section-you-can_2","title":"In this section, you can:","text":"<ul> <li>learn how to plot spatial tissue information from the G4X-data</li> <li>generate novel nuclear or cytoplasmic segmentations with popular models</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Got feedback or ideas for additional tutorials or documentation?  drop us a note at care@singulargenomics.com.  </p> <p> \u2e3b  </p> <p></p>"},{"location":"g4x_data/","title":"Index","text":""},{"location":"g4x_data/#g4x-data","title":"G4X-data","text":"<p>data.singulargenomics.com </p>"},{"location":"g4x_data/#output-reference-and-analysis-import-guides","title":"Output reference and analysis import guides.","text":"<p>The G4X produces multi-modal output containing tables, images, arrays and annotated matrices for single-cell analysis. The files found in the output directory are compatible with popular Python libraries from the <code>scverse</code> ecosystem, like <code>scanpy</code>, <code>rapids-singlecell</code>, <code>squidpy</code>, and <code>spatial-data</code>, and, if you prefer working in R, can be easily imported into <code>Seurat</code>.</p>"},{"location":"g4x_data/#in-this-section-you-will-find","title":"In this section you will find:","text":"<ul> <li>details on the G4X-output files and their organization</li> <li>guides on importing G4X-data into popular analysis tools in Python and R </li> </ul> <p> \u2e3b  </p>"},{"location":"g4x_data/data_import/","title":"Data import","text":""},{"location":"g4x_data/data_import/#g4x-data-import","title":"G4X-data import","text":"<p>The multi-modal output of the G4X spatial sequencer comprises images, tables and annotated data matrices, which allow deep exploration of your sample. The <code>single_cell_data</code> folder in the G4X-output contains the final processed form of the data, after transcript and image signals have been aggregated for each each segmented cell. There are several excellent open-source tools available that enable the full stack of analytical needs to gain biological insight from this data.  </p>"},{"location":"g4x_data/data_import/#below-we-illustrate-data-import-strategies-for-python-and-r-users","title":"Below we illustrate data import strategies for Python and R users:","text":""},{"location":"g4x_data/data_import/#if-you-are-working-in-python","title":"if you are working in Python","text":"<p>Some excellent tools are:</p> <ul> <li><code>scanpy</code>: full-featured single-cell analysis suite</li> <li><code>rapids-singlecell</code>: expands scanpy with GPU-support</li> <li><code>squidpy</code>: functionality for the analysis of spatial data</li> <li><code>spatial-data</code>: analysis and management of spatial data (requires data conversion)</li> </ul> <p></p> <p>All of these tools accept, or incorporate <code>anndata</code> objects as the basic representation of your single-cell data. There are several ways to load your data as an <code>anndata</code> object into your Python session. Below we will illustrate a few methods that will produce equivalent outputs.</p>"},{"location":"g4x_data/data_import/#1-g4x-helpers","title":"1. G4X-helpers","text":"<p>If you have G4X-helpers installed, you can use the <code>G4Xoutput()</code> class to access the anndata of your sample via the <code>load_adata()</code> method.</p> <pre><code>import g4x_helpers as g4x\n\nrun_base = '/path/to/g4x_output/sample_x1'\n\nsample = g4x.G4Xoutput(run_base=run_base)\nadata = sample.load_adata(remove_nontargeting=False, load_clustering=False) \n</code></pre> <p>Note: <code>load_adata()</code> options</p> <p>Two options are provided that will impact what will be loaded. In the above example we are overriding the default so that the output matches the other methods. <code>remove_nontargeting</code>: bool (default=True) <code>load_clustering</code>: bool (default=True)</p>"},{"location":"g4x_data/data_import/#2-scanpy","title":"2. scanpy","text":"<p>You can achieve the same result by pointing scanpy's <code>read_h5ad()</code> function the <code>feature_matrix.h5</code> in your G4X-output directory</p> <pre><code>from pathlib import Path\nimport scanpy as sc\n\nrun_base = Path('/path/to/g4x_output/sample_x1')\nad_file = run_base / 'single_cell_data' / 'feature_matrix.h5'\n\nadata = sc.read_h5ad(ad_file)\n</code></pre> <p>Note</p> <p>If you have G4X-helpers installed, then <code>scanpy</code> will be available as one of its dependencies. If not, please refer to the scanpy documentation for installation guides.</p>"},{"location":"g4x_data/data_import/#3-building-from-raw-data","title":"3. building from raw data","text":"<p>If you do not wish to use the pre-generated <code>feature_matrix.h5</code> you can replicate a similar object by reading the counts and cell metadata into an <code>anndata</code> object.</p> <pre><code>from pathlib import Path\nimport anndata as ad\nimport pandas as pd\nfrom scipy import sparse\n\nrun_base = Path('/path/to/g4x_output/sample_x1')\n\ntxcounts_path = run_base / 'single_cell_data' / 'cell_by_transcript.csv.gz'\nmetadata_path = run_base / 'single_cell_data' / 'cell_metadata.csv.gz'\n\ncounts = pd.read_csv(txcounts_path, index_col='label')\nX = sparse.csr_matrix(counts.values)\n\nmetadata = pd.read_csv(metadata_path, index_col='label')\n\nadata = ad.AnnData(X=X, obs=metadata)\nadata.var_names = counts.columns\n</code></pre> <p>Note</p> <p>If you have G4X-helpers installed, then <code>anndata</code>, <code>pandas</code> and <code>scipy</code> will be available as dependencies.</p> <p></p>"},{"location":"g4x_data/data_import/#if-you-are-working-in-r","title":"if you are working in R","text":"<p>The most feature rich package for single-cell analysis in R is:</p> <ul> <li><code>Seurat</code>: full-featured single-cell analysis suite with spatial analysis capabilities</li> </ul> <p>To work with your data in Seurat, it needs to be loaded into a <code>SeuratObject</code>, which is an annotated data structure.</p> <pre><code>library('Seurat')\n\nrun_base = c('/path/to/g4x_output/sample_x1')\n\ntxcounts_path = file.path(run_base, \"single_cell_data/cell_by_transcript.csv.gz\")\nmetadata_path = file.path(run_base, \"single_cell_data/cell_metadata.csv.gz\")\n\ncounts &lt;- read.csv(txcounts_path, row.names = 1) \ncounts &lt;- t(counts) # transpose to match Seurat input\n\nmetadata &lt;- read.csv(metadata_path, row.names = 1) \n\nsobj &lt;- CreateSeuratObject(counts = counts, meta.data = metadata)\n</code></pre> <p> \u2e3b  </p>"},{"location":"g4x_data/output_structure/","title":"Directory structure","text":""},{"location":"g4x_data/output_structure/#output-directory-structure","title":"Output directory structure","text":"<p>This page outlines the directory and file structure produced by the G4X processing pipeline. The overview below shows the main folders and files, helping users navigate and understand the organization of the output directory. For detailed descriptions of each file, see the output files section.</p> Multiomics Run Transcript Run <pre><code>&lt;root_directory&gt;\n\u251c\u2500\u2500 summary_{sample_id}.html\n\u251c\u2500\u2500 transcript_panel.csv\n\u251c\u2500\u2500 protein_panel.csv                   \n\u251c\u2500\u2500 samplesheet.csv\n\u251c\u2500\u2500 run_meta.json\n\u2502\n\u251c\u2500\u2500 g4x_viewer \n\u2502   \u251c\u2500\u2500 {sample_id}_multiplex.ome.tiff\n\u2502   \u251c\u2500\u2500 {sample_id}_nuclear.ome.tiff\n\u2502   \u251c\u2500\u2500 {sample_id}_HE.ome.tiff\n\u2502   \u251c\u2500\u2500 {sample_id}_segmentation.bin\n\u2502   \u251c\u2500\u2500 {sample_id}_transcripts.tar\n\u2502   \u2514\u2500\u2500 {sample_id}_run_metadata.json\n\u2502\n\u251c\u2500\u2500 h_and_e \n\u2502   \u251c\u2500\u2500 eosin.jp2\n\u2502   \u251c\u2500\u2500 eosin_thumbnail.png\n\u2502   \u251c\u2500\u2500 h_and_e.jp2\n\u2502   \u251c\u2500\u2500 h_and_e_thumbnail.jpg\n\u2502   \u251c\u2500\u2500 nuclear.jp2\n\u2502   \u2514\u2500\u2500 nuclear_thumbnail.png\n\u2502\n\u251c\u2500\u2500 metrics \n\u2502   \u251c\u2500\u2500 transcript_core_metrics.csv\n|   \u251c\u2500\u2500 protein_core_metrics.csv\n\u2502   \u2514\u2500\u2500 per_area_metrics.csv\n\u2502\n\u251c\u2500\u2500 protein                             \n\u2502   \u251c\u2500\u2500 bead_mask.npz\n\u2502   \u251c\u2500\u2500 {protein_1}.jp2\n\u2502   \u251c\u2500\u2500 {protein_1}_thumbnail.png\n\u2502   \u251c\u2500\u2500 {protein_2}.jp2\n\u2502   \u251c\u2500\u2500 {protein_2}_thumbnail.png\n\u2502   \u2514\u2500\u2500 \u2026\n\u2502\n\u251c\u2500\u2500 rna\n\u2502   \u251c\u2500\u2500 raw_features.parquet\n\u2502   \u2514\u2500\u2500 transcript_table.csv.gz\n\u2502\n\u251c\u2500\u2500 segmentation\n\u2502   \u2514\u2500\u2500 segmentation_mask.npz\n\u2502\n\u251c\u2500\u2500 single_cell_data\n\u2502   \u251c\u2500\u2500 feature_matrix.h5         \n\u2502   \u251c\u2500\u2500 cell_by_protein.csv.gz          \n\u2502   \u251c\u2500\u2500 cell_by_transcript.csv.gz\n\u2502   \u251c\u2500\u2500 cell_metadata.csv.gz\n\u2502   \u251c\u2500\u2500 clustering_umap.csv.gz\n\u2502   \u251c\u2500\u2500 dgex.csv.gz\n\u2502   \u251c\u2500\u2500 protein_singlecell_correlation.csv\n\u2502   \u2514\u2500\u2500 rna_protein_singlecell_correlation.csv\n\u2502\n\u2514\u2500\u2500 diagnostics\n    \u2514\u2500\u2500 (intentionally empty)\n</code></pre> <pre><code>&lt;root_directory&gt;\n\u251c\u2500\u2500 summary_{sample_id}.html\n\u251c\u2500\u2500 transcript_panel.csv\n\u251c\u2500\u2500 samplesheet.csv\n\u251c\u2500\u2500 run_meta.json\n\u2502\n\u251c\u2500\u2500 g4x_viewer \n\u2502   \u251c\u2500\u2500 {sample_id}_nuclear.ome.tiff\n\u2502   \u251c\u2500\u2500 {sample_id}_HE.ome.tiff\n\u2502   \u251c\u2500\u2500 {sample_id}_segmentation.bin\n\u2502   \u251c\u2500\u2500 {sample_id}_transcripts.tar\n\u2502   \u2514\u2500\u2500 {sample_id}_run_metadata.json\n\u2502\n\u251c\u2500\u2500 h_and_e \n\u2502   \u251c\u2500\u2500 eosin.jp2\n\u2502   \u251c\u2500\u2500 eosin_thumbnail.png\n\u2502   \u251c\u2500\u2500 h_and_e.jp2\n\u2502   \u251c\u2500\u2500 h_and_e_thumbnail.jpg\n\u2502   \u251c\u2500\u2500 nuclear.jp2\n\u2502   \u2514\u2500\u2500 nuclear_thumbnail.png\n\u2502\n\u251c\u2500\u2500 metrics \n\u2502   \u251c\u2500\u2500 transcript_core_metrics.csv\n\u2502   \u2514\u2500\u2500 per_area_metrics.csv\n\u2502\n\u251c\u2500\u2500 rna\n\u2502   \u251c\u2500\u2500 raw_features.parquet\n\u2502   \u2514\u2500\u2500 transcript_table.csv.gz\n\u2502\n\u251c\u2500\u2500 segmentation\n\u2502   \u2514\u2500\u2500 segmentation_mask.npz\n\u2502\n\u251c\u2500\u2500 single_cell_data\n\u2502   \u251c\u2500\u2500 feature_matrix.h5               \n\u2502   \u251c\u2500\u2500 cell_by_transcript.csv.gz\n\u2502   \u251c\u2500\u2500 cell_metadata.csv.gz\n\u2502   \u251c\u2500\u2500 clustering_umap.csv.gz\n\u2502   \u2514\u2500\u2500 dgex.csv.gz\n\u2502\n\u2514\u2500\u2500 diagnostics\n    \u2514\u2500\u2500 (intentionally empty)\n</code></pre> <p>  \u2e3b   </p>"},{"location":"g4x_data/output_files/","title":"Index","text":""},{"location":"g4x_data/output_files/#output-file-reference","title":"Output file reference","text":"<p>This page provides a comprehensive reference for all output files generated by the G4X platform. It describes the contents of each directory and file type. Special notes are included for files specific to multiomics runs. The documentation also highlights file compatibility with the G4X-viewer and provides detailed column descriptions for key tables.</p> <p> This symbol indicates that these files are only available in multiomics runs.</p>"},{"location":"g4x_data/output_files/diagnostics/","title":"diagnostics","text":""},{"location":"g4x_data/output_files/diagnostics/#diagnostics","title":"diagnostics","text":"<p>This folder is intentionally left empty.</p>"},{"location":"g4x_data/output_files/g4x_viewer/","title":"g4x_viewer","text":""},{"location":"g4x_data/output_files/g4x_viewer/#g4x_viewer","title":"g4x_viewer","text":"<p>The files in this directory are G4X-viewer compatible representations of the dataset. They contain much of the same information as found in the raw data outputs, but with reduced fidelity to optimize performance for interactive viewing. These files are not intended for quantitative analysis and should be used only for visual exploration with the G4X-viewer. Please refer to the G4X-viewer documentation for more information.</p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_segmentationbin","title":"<code>{sample_id}_segmentation.bin</code>","text":"<p>Viewer input field: UPLOAD SEGMENTATION FILE</p> <p>Binary file containing cell segmentation polygons and other cell metadata. This file can be updated with new metadata using the <code>update_bin</code> function of G4X-helpers.</p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_run_metadatajson","title":"<code>{sample_id}_run_metadata.json</code>","text":"<p>Viewer input field: UPLOAD METADATA</p> <p>JSON file containing much of the same information as the <code>run_meta.json</code> along with core metrics for the specific block (e.g. <code>total_tissue_area_mm^2</code>, <code>median_transcripts_per_cell</code>). File names match the sample ID (for example: <code>A01_run_metadata.json</code>).</p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_transcriptstar","title":"<code>{sample_id}_transcripts.tar</code>","text":"<p>Viewer input field: UPLOAD TRANSCRIPT FILE</p> <p>Tarball containing the viewer-ready transcript locations and metadata (gene names &amp; colors). Load this into the G4X-viewer under \"Upload Transcript File\".</p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_multiplexometiff","title":"<code>{sample_id}_multiplex.ome.tiff</code>","text":"<p>Viewer input field: UPLOAD IMAGE FILE</p> <p>Multi-channel OME-tiff file containing aggregated images for all protein targets as well as nuclear and cytoplasmic stains. Note: On windows, this may appear as <code>{sample_id}_multiplex.ome</code>.</p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_heometiff","title":"<code>{sample_id}_HE.ome.tiff</code>","text":"<p>Viewer input field: ADD FH&amp;E IMAGE (Brightfield Settings)</p> <p>Single-channel RGB OME-tiff file containing the fH&amp;E image. This file should be loaded in the \"Brightfield Images Settings\" in the G4X-viewer.   </p>"},{"location":"g4x_data/output_files/g4x_viewer/#sample_id_nuclearometiff","title":"<code>{sample_id}_nuclear.ome.tiff</code>","text":"<p>Viewer input field: UPLOAD IMAGE FILE</p> <p>Multi-channel OME-tiff file containing aggregated images for the nuclear and cytoplasmic stains. In multiomics runs, these channels are also included in <code>{sample_id}_multiplex.ome.tiff</code>.   </p> ome.tiff compatibility <p>All provided <code>*.ome.tiff</code> files can also be loaded into other standard ome.tiff readers, including Fiji, and napari.  </p> <p></p>"},{"location":"g4x_data/output_files/h_and_e/","title":"h_and_e","text":""},{"location":"g4x_data/output_files/h_and_e/#h_and_e","title":"h_and_e","text":""},{"location":"g4x_data/output_files/h_and_e/#h_and_ejp2","title":"<code>h_and_e.jp2</code>","text":"<p>Raw, full-sized fH&amp;E image.</p>"},{"location":"g4x_data/output_files/h_and_e/#nuclearjp2","title":"<code>nuclear.jp2</code>","text":"<p>Raw, full-sized nuclear stain image and its thumbnail.</p>"},{"location":"g4x_data/output_files/h_and_e/#cytoplasmicjp2","title":"<code>cytoplasmic.jp2</code>","text":"<p>Raw, full-sized cytoplasmic stain image and its thumbnail.</p>"},{"location":"g4x_data/output_files/h_and_e/#image_thumbnailjpgpng","title":"<code>{image}_thumbnail.jpg/png</code>","text":"<p>Reduced size and compressed thumbnail of each image for easy viewing in standard applications. These files are not suitable for quantitative analysis.</p> segmentation input <p>The .jp2 images in this and the <code>protein</code> folder are suitable to use for both nuclear and cytoplasmic segmentation. For more information on how you might do this, see segment data.</p>"},{"location":"g4x_data/output_files/metrics/","title":"metrics","text":""},{"location":"g4x_data/output_files/metrics/#metrics","title":"metrics","text":""},{"location":"g4x_data/output_files/metrics/#transcript_core_metricscsv","title":"<code>transcript_core_metrics.csv</code>","text":"<p>CSV file containing a set of core metrics for the sample including total transcripts, total area, number of cells and more.</p>"},{"location":"g4x_data/output_files/metrics/#protein_core_metricscsv","title":"<code>protein_core_metrics.csv</code>","text":"<p>CSV file containing core protein metrics for the sample, such as signal-to-noise ratio (SNR), background intensity, and Fisher's exact test scores. Fisher scores assess the co-occurrence of each protein signal with its corresponding transcripts (<code>&lt;protein&gt;_fisher_score</code>) and with a random background set (<code>&lt;protein&gt;_fisher_background_score</code>). If no protein-gene pairs are present, the value is <code>unavailable</code>; if the score cannot be computed, the entry is <code>NaN</code>.</p>"},{"location":"g4x_data/output_files/metrics/#per_area_metricscsv","title":"<code>per_area_metrics.csv</code>","text":"<p>CSV file containing a set of metrics for 100\u00a0\u00b5m<sup>2</sup> bins across the sample. Values included area identifiers <code>x/y_bin</code>, area coordinates <code>x/y_bin_min_pixel_coordinate</code>, and total number of transcripts and number of cells for each area.</p>"},{"location":"g4x_data/output_files/protein/","title":"protein","text":""},{"location":"g4x_data/output_files/protein/#protein","title":"protein","text":"<p>This folder is only present in multiomics runs </p>"},{"location":"g4x_data/output_files/protein/#proteinjp2","title":"<code>{protein}.jp2</code>","text":"<p>Raw, full-sized protein detection image for <code>{protein}</code>. The values in the cell_metadata and cell_by_protein tables are derived by applying cell segmentation masks over these protein images.</p>"},{"location":"g4x_data/output_files/protein/#protein_thumbnailpng","title":"<code>{protein}_thumbnail.png</code>","text":"<p>Reduced size and compressed thumbnail of each protein image for easy viewing in standard applications. These files are not suitable for quantitative analysis.</p>"},{"location":"g4x_data/output_files/protein/#bead_masknpz","title":"<code>bead_mask.npz</code>","text":"<p>Compressed numpy archive containing a boolean bead masks. The file marks regions where focusing beads were detected and is used to remove signal in those areas.</p>"},{"location":"g4x_data/output_files/rna/","title":"rna","text":""},{"location":"g4x_data/output_files/rna/#rna","title":"rna","text":""},{"location":"g4x_data/output_files/rna/#raw_featuresparquet","title":"<code>raw_features.parquet</code>","text":"<p>Parquet file containing raw transcript feature information pre-demultiplexing. It lists sequence, coordinates and quality scores of all detected features. This file is required for the <code>redemux</code> feature of G4X-helpers.</p> column type description <code>TXUID</code> str Unique identifier for the transcript <code>x_pixel_coordinate</code> float The x-coordinate for the transcript <code>y_pixel_coordinate</code> float The y-coordinate for the transcript <code>z_layer</code> int z layer of identified transcript <code>confidence_score</code> float Mean quality score for the transcript"},{"location":"g4x_data/output_files/rna/#transcript_tablecsvgz","title":"<code>transcript_table.csv.gz</code>","text":"<p>CSV file listing all successfully demultiplexed transcript features. Includes all columns from <code>raw_features.parquet</code>, with additional probe names, gene names, and assigned <code>cell_id</code> values for each feature. The values in the cell_by_transcript table are derived by applying cell segmentation masks over these transcripts.</p> column type description <code>x_pixel_coordinate</code> float The x coordinate for the transcript <code>y_pixel_coordinate</code> float The y coordinate for the transcript <code>z_level</code> int Z layer index of the transcript <code>probe_name</code> str Probe identifier used for decoding <code>gene_name</code> str Gene symbol for the decoded probe <code>confidence_score</code> float Mean quality score for the transcript <code>in_nucleus</code> int Cell nucleus the transcript is assigned to (0 = not assigned) <code>cell_id</code> int Cell the transcript is assigned to (0 = not assigned)"},{"location":"g4x_data/output_files/root_directory/","title":"root directory","text":""},{"location":"g4x_data/output_files/root_directory/#root-directory","title":"root directory","text":""},{"location":"g4x_data/output_files/root_directory/#summary_sample_idhtml","title":"<code>summary_{sample_id}.html</code>","text":"<p>HTML file which gives a high level overview of the experiment outputs, data quality, and performance for the specific sample.</p>"},{"location":"g4x_data/output_files/root_directory/#run_metajson","title":"<code>run_meta.json</code>","text":"<p>JSON file containing global run information, such as software version, instrument ID, and platform details. It also includes the source files used for the transcript and protein panels.</p>"},{"location":"g4x_data/output_files/root_directory/#samplesheetcsv","title":"<code>samplesheet.csv</code>","text":"<p>CSV file containing detailed run information, including operator, experimental design, run parameters, flow cell layout, tissue type, and panels used. Also specifies the position of each tissue section on the flow cell.</p>"},{"location":"g4x_data/output_files/root_directory/#transcript_panelcsv","title":"<code>transcript_panel.csv</code>","text":"<p>CSV file containing a full list of all probes used to demultiplex the detected features in the data.</p>"},{"location":"g4x_data/output_files/root_directory/#protein_panelcsv","title":"<code>protein_panel.csv</code>","text":"<p>CSV file containing a full list of all targeted proteins in this experiment and the panel type (standard, addon).</p>"},{"location":"g4x_data/output_files/segmentation/","title":"segmentation","text":""},{"location":"g4x_data/output_files/segmentation/#segmentation","title":"segmentation","text":""},{"location":"g4x_data/output_files/segmentation/#segmentation_masknpz","title":"<code>segmentation_mask.npz</code>","text":"<p>Compressed numpy array file containing the segmentation mask. This archive holds two arrays: <code>nuclei</code> (nuclear segmentation) and <code>nuclei_exp</code> (expanded nuclear mask, i.e whole-cell approximation). Label IDs correspond to the <code>cell_id/label</code> fields used in single_cell_data.</p>"},{"location":"g4x_data/output_files/single_cell_data/","title":"single_cell_data","text":""},{"location":"g4x_data/output_files/single_cell_data/#single_cell_data","title":"single_cell_data","text":""},{"location":"g4x_data/output_files/single_cell_data/#cell_metadatacsvgz","title":"<code>cell_metadata.csv.gz</code>","text":"<p>CSV file containing the metadata associated with each cell, including cell_id, cell area, transcript counts and protein content if available. This can be used to build single-cell analysis objects (Seurat/Scanpy) and perform downstream analyses. For more information, see data import.</p> name type description <code>label</code> str Unique cell-id derived from segmentation mask <code>cell_x/y</code> float x/y coordinate of the cell centroid <code>nuclei_area</code> int Area of the nuclear segmentation <code>nuclei_expanded_area</code> int Area of the expanded nuclear segmentation <code>total_counts</code> int Total transcript counts <code>log1p_total_counts</code> float Log number of total transcripts <code>n_genes_by_counts</code> int Number of unique genes detected <code>log1p_n_genes_by_counts</code> float Log number of unique genes detected <code>*stain_intensity_mean</code> float Mean intensity for nuclear and cytoplasmic stains <code>&lt;protein&gt;_intensity_mean</code> float Mean intensity for a given protein"},{"location":"g4x_data/output_files/single_cell_data/#cell_by_transcriptcsvgz","title":"<code>cell_by_transcript.csv.gz</code>","text":"<p>CSV file containing the cell x transcript matrix. Each entry in the table is the counts for a given transcript in a given cell.</p>"},{"location":"g4x_data/output_files/single_cell_data/#clustering_umapcsvgz","title":"<code>clustering_umap.csv.gz</code>","text":"<p>CSV file containing pre-computed cluster annotations and UMAP coordinates for each cell. </p>"},{"location":"g4x_data/output_files/single_cell_data/#dgexcsvgz","title":"<code>dgex.csv.gz</code>","text":"<p>CSV file containing differential gene expression (DGEx) results for the pre-computed clusters from the clustering_umap table.</p> column type description <code>names</code> str Gene symbol <code>scores</code> float Z-score from Wilcoxon rank-sum test <code>logfoldchanges</code> float LogFoldChange for the given cluster compared to all other clusters combined <code>pvals</code> float P-value from Wilcoxon rank-sum test <code>pvals_adj</code> float Adjusted P-value <code>pct_nz_group</code> float Percentage of non-zero values in the given cluster. <code>pct_nz_reference</code> float Percentage of non-zero values in all cells outside the given cluster. <code>group</code> int Leiden cluster identity <code>leiden_res</code> str Leiden clustering resolution that this entry is derived from (1 per gene per cluster)"},{"location":"g4x_data/output_files/single_cell_data/#feature_matrixh5","title":"<code>feature_matrix.h5</code>","text":"<p>H5 file containing the cell by transcript matrix with cell and transcript metadata. This file can be loaded into Python and used in <code>scanpy</code> or a number of other pipelines. See data import. The h5.obs table is equivalent to cell_metadata</p>"},{"location":"g4x_data/output_files/single_cell_data/#cell_by_proteincsvgz","title":"<code>cell_by_protein.csv.gz</code>","text":"<p>CSV file containing cell x protein intensity matrix. Each entry in the table is the average protein intensity for a given protein in a cell.</p>"},{"location":"g4x_data/output_files/single_cell_data/#rna_protein_singlecell_correlationcsv","title":"<code>rna_protein_singlecell_correlation.csv</code>","text":"<p>CSV file containing a square correlation matrix between selected transcript counts and protein intensity means, computed per cell. Useful for quickly checking concordance between RNA and protein markers (e.g. <code>CD4</code> counts vs <code>CD4_intensity_mean</code>).</p>"},{"location":"g4x_data/output_files/single_cell_data/#protein_singlecell_correlationcsv","title":"<code>protein_singlecell_correlation.csv</code>","text":"<p>CSV file containing a protein-by-protein correlation matrix of per-cell intensity means, allowing assessment of protein marker co-expression.</p>"},{"location":"g4x_tutorials/","title":"Index","text":""},{"location":"g4x_tutorials/#g4x-tutorials","title":"G4X-tutorials","text":""},{"location":"g4x_tutorials/#getting-started-analyzing-g4x-data","title":"Getting started analyzing G4X-data","text":"<p>G4X Tutorials are a collection of example workflows that demonstrate how to analyze G4X-data using popular Python and R libraries. These tutorials cover a wide range of topics, from basic visualizations to advanced analysis techniques.</p>"},{"location":"g4x_tutorials/#in-this-section-you-can","title":"In this section you can:","text":"<ul> <li>learn how to plot spatial tissue information from the G4X-data</li> <li>generate novel nuclear or cytoplasmic segmentations with popular models</li> <li>More coming soon!</li> </ul> <p> \u2e3b  </p>"},{"location":"g4x_tutorials/plot_spatial/","title":"Plot spatial","text":""},{"location":"g4x_tutorials/plot_spatial/#plotting-spatial-data-on-the-g4x","title":"Plotting Spatial Data on the G4X","text":"<p>One of the first things you'll want to do with your spatial data is to visualize your data on a spatial plot. G4X outputs are designed to make this information easy to access and plot in a variety of ways. With the tables and data structures provided, you can create a variety of spatial visualizations using tools like Seurat in R or scanpy in Python.</p> <p></p>"},{"location":"g4x_tutorials/plot_spatial/#python-visualization","title":"Python Visualization","text":"<p>This brief tutorial uses the scanpy library and assume that you have a working installation of it on your local system. If you do not, please see the scanpy installation guide for instructions on how to install it.</p>"},{"location":"g4x_tutorials/plot_spatial/#1-import-libraries","title":"1. Import libraries","text":"<pre><code># Import necessary libraries\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#2-load-your-data","title":"2. Load your data","text":"<pre><code># Load your data\nadata = sc.read_h5ad('path/to/your/data.h5ad')\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#3-extract-spatial-coordinates-into-a-scanpy-obsm-layer-for-scanpy-compatibility","title":"3. Extract spatial coordinates into a scanpy <code>obsm</code> layer for scanpy compatibility","text":"<pre><code># Extract spatial coordinates into obsm layer\nadata.obsm['X_spatial_cell'] = adata.obs[['cell_x', 'cell_y']].to_numpy()\n</code></pre> <p>Note</p> <p>In order for scanpy to extract this information for default plotting, you have to put <code>(x, y)</code> coordinate pairs for each cell into the <code>obsm</code> layer and name it something starting with <code>X_</code>. You can do this with any pair of coordinates.</p>"},{"location":"g4x_tutorials/plot_spatial/#4-plot-the-spatial-coordinates","title":"4. Plot the spatial coordinates","text":"<pre><code># Plot the spatial coordinates\nplt.figure(figsize=(10,8))\nax = sc.pl.scatter(adata, basis='spatial_cell', color='log1p_total_counts', show=False)\n\n# Flip the y-axis to match image orientation\nax.invert_yaxis()\nplt.show()\n</code></pre> <p>Note</p> <p>Here, we're plotting with the <code>color='log1p_total_counts'</code> to visualize the log total transcript counts per cell, but you can replace this with any other variable in your <code>adata.obs</code> or <code>adata.var</code> that is the correct dimensions (1xncells) to visualize different aspects of your data.</p>"},{"location":"g4x_tutorials/plot_spatial/#5-save-the-plot-as-a-png-file","title":"5. Save the plot as a PNG file","text":"<pre><code># Save the plot as PNG\nplt.savefig(\"spatial_plot.png\", dpi=300, bbox_inches='tight')\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#r-visualization","title":"R Visualization","text":"<p>This brief tutorial uses the ggplot2 library and assumes that you have a working installation of it on your local system. If you do not, please see the ggplot2 installation guide for instructions on how to install it.</p>"},{"location":"g4x_tutorials/plot_spatial/#1-load-necessary-libraries","title":"1. Load necessary libraries","text":"<pre><code># Load necessary libraries\nlibrary(ggplot2)\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#2-load-your-data-and-create-a-seurat-object","title":"2. Load your data and create a Seurat object","text":"<pre><code># Load your data and create a Seurat object\nrun_base = c('/path/to/g4x_output/&lt;sample_id&gt;')\nmetadata_path = file.path(run_base, \"single_cell_data/cell_metadata.csv.gz\")\nmeta &lt;- read.csv(gzfile(metadata_path), row.names = 1)\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#3-plot-spatial-coordinates-with-ggplot2","title":"3. Plot spatial coordinates with ggplot2","text":"<pre><code># Ensure coordinates are numeric\nmeta$cell_x &lt;- as.numeric(meta$cell_x)\nmeta$cell_y &lt;- as.numeric(meta$cell_y)\n\np &lt;- ggplot(meta, aes(x = cell_x, y = cell_y, color=log1p_total_counts)) +\n  geom_point(size = 0.3, alpha = 0.6) +\n  scale_y_reverse() +           # &lt;-- invert Y\n  coord_equal() +\n  labs(x = \"cell_x\", y = \"cell_y\", color = \"log1p(total_counts)\") +\n  theme_minimal()\n\nprint(p)\n</code></pre> <p>Note</p> <p>Here, we're plotting with the <code>color='log1p_total_counts'</code> to visualize the log total transcript counts per cell, but you can replace this with any other variable in your <code>meta</code> dataframe that is the correct dimensions (1xncells) to visualize different aspects of your data.</p>"},{"location":"g4x_tutorials/plot_spatial/#4-save-the-plot-as-a-png-file","title":"4. Save the plot as a PNG file","text":"<p><pre><code># Save as Plot as PNG\nggplot2::ggsave(\n  filename = \"cell_xy_log1p_total_counts.png\",\n  plot     = p,\n  width    = 8, height = 8, dpi = 300, units = \"in\",\n  bg       = \"white\"   \n)\n</code></pre> </p> <p>  \u2e3b   </p>"},{"location":"g4x_tutorials/segment_data/","title":"Segment data","text":""},{"location":"g4x_tutorials/segment_data/#segmenting-g4x-data","title":"Segmenting G4X-data","text":"<p>Here, we lay out a basic approach to resegment your G4X-data. We strongly encourage you to start this process by looking at the existing segmentation using our G4X-viewer. This will allow you to identify where it fails to capture your desired cell morphology. </p> <p>These instructions are designed to help you take the .jp2 images described in the G4X-data output documentation and run your own segmentation using Cellpose 2. This is typically an iterative process.</p>"},{"location":"g4x_tutorials/segment_data/#_1","title":"Segment data","text":""},{"location":"g4x_tutorials/segment_data/#basic-segmentation-approach","title":"Basic segmentation approach","text":"<p>For this tutorial, we use the most basic Cellpose arguments. It is strongly encouraged that you look into the Cellpose documentation for more advanced options that may suit your needs.</p>"},{"location":"g4x_tutorials/segment_data/#1-import-libraries","title":"1. Import libraries","text":"<p><pre><code>import numpy as np\nimport glymur\nfrom cellpose import models\nfrom cellpose.models import CellposeModel\nfrom skimage.exposure import rescale_intensity\n</code></pre> </p>"},{"location":"g4x_tutorials/segment_data/#2-choose-which-type-of-segmentation-you-want-to-run","title":"2. Choose which type of segmentation you want to run","text":"Nuclear OnlyNuclear +1 markerNuclear +2 markers"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-image-using-glymur","title":"3. Load the .jp2 image using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-your-nuclear-image-to-the-range-0-1","title":"4. Normalize your nuclear image to the range 0-1","text":"<pre><code># --- Normalize nuclear image ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-run-nuclear-segmentation","title":"5. Run nuclear segmentation","text":"<pre><code># --- Run nuclear model ---\nmodel = models.CellposeModel(gpu=True, model_type=\"nuclear\")\nmasks, flows, styles = model.eval(nuclear_norm_subset, channels=[0],\n                                    normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-images-using-glymur","title":"3. Load the .jp2 images using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\nmarker1 = glymur.Jp2k(\"path/to/marker1.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-each-image-channel-to-the-range-0-1","title":"4. Normalize each image channel to the range 0-1","text":"<pre><code># --- Normalize each channel separately ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\nmarker1_norm = rescale_intensity(marker1, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-stack-your-channels-for-cellpose-input","title":"5. Stack your channels for Cellpose input","text":"<pre><code># --- Stack channels:  marker1_norm = channel 0, nuclear = channel 1 ---\ninput_img = np.stack([marker1_norm, nuclear_norm], axis=2)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#6-run-cyto3-segmentation","title":"6. Run Cyto3 segmentation","text":"<pre><code># --- Run Cyto3 ---\nmodel = models.Cellpose(gpu=True, model_type=\"cyto3\")\nmasks, flows, styles, diams = model.eval(input_img, channels=[1, 0], \n                                            normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-images-using-glymur_1","title":"3. Load the .jp2 images using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\nmarker1 = glymur.Jp2k(\"path/to/marker1.jp2\")[:]\nmarker2 = glymur.Jp2k(\"path/to/marker2.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-each-image-channel-to-the-range-0-1_1","title":"4. Normalize each image channel to the range 0-1","text":"<pre><code># --- Normalize each channel separately ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\nmarker1_norm = rescale_intensity(marker1, out_range=(0, 1))\nmarker2_norm = rescale_intensity(marker2, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-perform-averaging-of-markers-to-create-a-combined-membrane-channel","title":"5. Perform averaging of markers to create a combined membrane channel","text":"Simple AverageWeighted Average <pre><code># combine membrane markers\nmembrane_combo = (marker1_norm + marker2_norm) / 2  # simple average\n</code></pre> <pre><code># weighted average (sum of weights should be 1)\nmarker1_weight = 0.35\nmarker2_weight = 0.65\nmembrane_combo = ((marker1_weight * marker1_norm) + \n                    (marker2_weight * marker2_norm))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#6-stack-your-channels-for-cellpose-input","title":"6. Stack your channels for Cellpose input","text":"<pre><code># --- Stack channels:  membrane = channel 0, nuclear = channel 1 ---\ninput_img = np.stack([membrane_combo, nuclear_norm], axis=2)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#7-run-cyto3-segmentation","title":"7. Run Cyto3 segmentation","text":"<pre><code># --- Run Cyto3 ---\nmodel = models.Cellpose(gpu=True, model_type=\"cyto3\")\nmasks, flows, styles, diams = model.eval(input_img, channels=[1, 0], \n                                            normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#iterating-on-your-segmentation","title":"Iterating on your segmentation","text":"<p>After you've generated your segmentation masks, you sould take time to visualize them and determine if they are meeting your needs. This is an iterative process that may take several rounds of tuning. </p> <p>To save time, you may want to consider using some basic python plotting as well as subsetting your data to speed up iteration. Below are examples of each.</p> <p></p>"},{"location":"g4x_tutorials/segment_data/#visualize-your-segmentation","title":"Visualize your segmentation","text":"<p>Here is a snippet of code to visualize your segmentation masks overlaid on a single fluorescent image. Notably, the variable this uses are:</p> <ul> <li><code>marker_image</code>: a single fluorescent image (e.g. nuclear or membrane) to show the cell outlines against (same dimensions as <code>masks</code>)</li> <li><code>masks</code>: the generated segmentation masks from Cellpose</li> </ul> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8,8))\n\n# Show the fluorescent image in blue with a bit of transparency\nvmax = np.percentile(marker_image, 99) # remove hot pixels\nplt.imshow(\n    marker_image, \n    cmap=\"Blues\", vmin=0, vmax=vmax, alpha=0.8, origin=\"lower\"\n)\n\n# Draw one contour around each labeled cell\n# using half-integer levels to outline integer labels cleanly\nlevels = np.arange(0.5, masks.max() + 0.5, 1.0)\nplt.contour(masks, levels=levels, colors=\"gray\", \n                linewidths=0.7, origin=\"lower\") \n\nplt.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"g4x_tutorials/segment_data/#subset-your-images","title":"Subset your images","text":"<p>Since this process can take quite a while on our stitched images, you may want to try to hone your approach first on a smaller, cropped image. For example, after loading your .jp2 image(s), you can subset them with something like this, running your segmentation on that block only:</p> <pre><code>sz = 1000 # max size of your subset block\n\n# get the image size\nx = marker_norm.shape[0]\ny = marker_norm.shape[1]\n\n# take the middle 1000 x 1000 pixel block\nmarker_subset = marker_norm[int((y/2)-int(sz/2)):int((y/2)+int(sz/2)),\n                            int((x/2)-int(sz/2)):int((x/2)+int(sz/2))]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#applying-your-segmentation","title":"Applying your segmentation","text":"<p>Once you are happy with the outputs, you are ready to save them and run our G4X-helpers tool to regenerate your single cell data using your new segmentation masks.</p>"},{"location":"g4x_tutorials/segment_data/#save-your-segmentation-masks","title":"Save your segmentation masks","text":"<pre><code># ---- Save generated masks ----\nnp.save(\"/path/to/output/folder/resegmented_masks.npy\", masks)\nnp.savez_compressed(\"/path/to/output/folder/resegmented_masks.npz\", \n                    nuclei=masks, nuclei_exp=masks)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#regenerate-your-g4x-outputs","title":"Regenerate your G4X outputs","text":"<p>After you have a segmentation that you are happy with, use out resegmentation tool to regenerate it for each tissue block. For installation tips, see our guide on installing G4X-helpers. For advanced usage tips, see our resegment documentation.</p> <pre><code>resegment \n    --run_base /path/to/data/dir/&lt;block_id&gt;\n    --segmentation_mask /path/to/new/masks.npy \n    --out_dir /path/to/output/dir/\n</code></pre> <p></p> <p> \u2e3b  </p>"}]}