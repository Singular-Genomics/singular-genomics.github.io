{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docs Home","text":""},{"location":"#singular-genomics-docs","title":"Singular Genomics Docs","text":"<p>singulargenomics.com </p> <p>These pages provide documentation, example workflows, and helper tools for analyzing, and post-processing data generated by the G4X spatial sequencer.</p> <p></p>"},{"location":"#g4x-helpers","title":"G4X-helpers","text":""},{"location":"#post-processing-tools-and-helper-models-for-g4x-data","title":"Post-processing tools and helper models for G4X-data","text":"<p>With G4X-helpers we provide an open-source toolkit for common post-processing tasks \u2014 such as applying custom segmentations or adding your own labels to the G4X-viewer. You can access its core features from the command-line interface (CLI) and additionally import it as a standalone Python package to interact with your data.</p>"},{"location":"#in-this-section-you-can","title":"In this section, you can:","text":"<ul> <li>learn how to install G4X-helpers on your system</li> <li>get started with using the command line interface (CLI)</li> <li>find a description of its CLI features </li> </ul>"},{"location":"#g4x-viewer","title":"G4X-viewer","text":""},{"location":"#explore-and-visualize-your-g4x-data","title":"Explore and visualize your G4X-data","text":"<p>The G4X-viewer is a Python-based, multi-purpose, interactive viewer specifically designed to help you explore your G4X-data. The G4X-viewer is accessible through our website or can be downloaded from GitHub as a standalone application and hosted locally.</p>"},{"location":"#in-this-section-you-can_1","title":"In this section, you can:","text":"<ul> <li>find resources to learn how to navigate your data with the G4X-viewer</li> </ul>"},{"location":"#g4x-data","title":"G4X-data","text":""},{"location":"#reference-documentation-for-g4x-output-files","title":"Reference documentation for G4X-output files","text":"<p>The G4X produces multi-modal output containing tables, images, arrays and annotated matrices for single-cell analysis. The files found in the output directory are compatible with popular Python libraries from the <code>scverse</code> ecosystem, like <code>scanpy</code>, <code>rapids-singlecell</code>, <code>squidpy</code>, and <code>spatial-data</code>, and, if you prefer working in R, can be easily imported into <code>Seurat</code>.</p>"},{"location":"#in-this-section-you-will-find","title":"In this section, you will find:","text":"<ul> <li>details on the G4X-output files and their organization</li> <li>guides on importing G4X-data into popular analysis tools in Python and R </li> </ul>"},{"location":"#g4x-tutorials","title":"G4X-tutorials","text":""},{"location":"#get-started-analyzing-your-data","title":"Get started analyzing your data","text":"<p>G4X Tutorials are a collection of example workflows that demonstrate how to analyze G4X-data using popular Python and R libraries. These tutorials cover a wide range of topics, from basic data import and visualization to advanced analysis techniques.</p>"},{"location":"#in-this-section-you-can_2","title":"In this section, you can:","text":"<ul> <li>learn how to plot spatial tissue information from the G4X-data</li> <li>generate novel nuclear or cytoplasmic segmentations with popular models</li> </ul>"},{"location":"#support","title":"support","text":"<p>Got feedback or ideas for additional tutorials or documentation?  drop us a note at care@singulargenomics.com.  </p> <p>\u2e3b</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v022-2025-10-01","title":"<code>v0.2.2</code> \u2014 [2025-10-01]","text":"<ul> <li>docs: fixed broken links</li> <li>docs: spell-check and formatting</li> <li>docs: specific toc_depth in changelog</li> </ul>"},{"location":"changelog/#v021-2025-09-29","title":"<code>v0.2.1</code> \u2014 [2025-09-29]","text":"<ul> <li>page-specific toc_depth on main page</li> <li>updated _core</li> <li>typo in CHANGELOG</li> </ul>"},{"location":"changelog/#v020-2025-09-29","title":"<code>v0.2.0</code> \u2014 [2025-09-29]","text":"<ul> <li>carrying over changes from prev. docs page</li> <li>formatting</li> <li>logo consistency</li> <li>edits suggested by FAS team</li> <li>added changelog and updated _core</li> <li>set-up uv-ship config</li> </ul>"},{"location":"changelog/#v010-2025-09-19","title":"<code>v0.1.0</code> \u2014 [2025-09-19]","text":""},{"location":"changelog/#mkdocs-integration","title":"mkdocs integration","text":"<ul> <li>initialized shared documentation structure across sites/repos</li> <li>added core docs submodule and set up inheritance</li> <li>added .gitignore</li> <li>added CNAME to docs so it gets copied during deployment</li> <li>added docs deploy workflow</li> <li>added maintenance message to docs page</li> </ul>"},{"location":"g4x_data/","title":"Index","text":""},{"location":"g4x_data/#g4x-data","title":"G4X-data","text":""},{"location":"g4x_data/#output-reference-and-analysis-import-guides","title":"Output reference and analysis import guides.","text":"<p>The G4X produces multi-modal output containing tables, images, arrays and annotated matrices for single-cell analysis. The files found in the output directory are compatible with popular Python libraries from the <code>scverse</code> ecosystem, like <code>scanpy</code>, <code>rapids-singlecell</code>, <code>squidpy</code>, and <code>spatial-data</code>, and, if you prefer working in R, can be easily imported into <code>Seurat</code>.</p>"},{"location":"g4x_data/#in-this-section-you-will-find","title":"In this section you will find:","text":"<ul> <li>details on the G4X-output files and their organization</li> <li>guides on importing G4X-data into popular analysis tools in Python and R </li> </ul> <p>\u2e3b</p>"},{"location":"g4x_data/data_import/","title":"data import","text":""},{"location":"g4x_data/data_import/#g4x-data-import","title":"G4X-data import","text":"<p>The multi-modal output of the G4X spatial sequencer comprises images, tables and annotated data matrices, which allow deep exploration of your sample. The <code>single_cell_data</code> folder in the G4X-output contains the final processed form of the data, after transcript and image signals have been aggregated for each each segmented cell. There are several excellent open-source tools available that enable the full stack of analytical needs to gain biological insight from this data.  </p>"},{"location":"g4x_data/data_import/#below-we-illustrate-data-import-strategies-for-python-and-r-users","title":"Below we illustrate data import strategies for Python and R users:","text":""},{"location":"g4x_data/data_import/#if-you-are-working-in-python","title":"if you are working in Python","text":"<p>Some excellent tools are:</p> <ul> <li><code>scanpy</code>: full-featured single-cell analysis suite</li> <li><code>rapids-singlecell</code>: expands scanpy with GPU-support</li> <li><code>squidpy</code>: functionality for the analysis of spatial data</li> <li><code>spatial-data</code>: analysis and management of spatial data (requires data conversion)</li> </ul> <p></p> <p>All of these tools accept, or incorporate <code>anndata</code> objects as the basic representation of your single-cell data. There are several ways to load your data as an <code>anndata</code> object into your Python session. Below we will illustrate a few methods that will produce equivalent outputs.</p>"},{"location":"g4x_data/data_import/#1-g4x-helpers","title":"1. G4X-helpers","text":"<p>If you have G4X-helpers installed, you can use the <code>G4Xoutput()</code> class to access the anndata of your sample via the <code>load_adata()</code> method.</p> <pre><code>import g4x_helpers as g4x\n\nrun_base = '/path/to/g4x_output/sample_x1'\n\nsample = g4x.G4Xoutput(run_base=run_base)\nadata = sample.load_adata(remove_nontargeting=False, load_clustering=False) \n</code></pre> <p>Note: <code>load_adata()</code> options</p> <p>Two options are provided that will impact what will be loaded. In the above example we are overriding the default so that the output matches the other methods. <code>remove_nontargeting</code>: bool (default=True) <code>load_clustering</code>: bool (default=True)</p>"},{"location":"g4x_data/data_import/#2-scanpy","title":"2. scanpy","text":"<p>You can achieve the same result by pointing scanpy's <code>read_h5ad()</code> function the <code>feature_matrix.h5</code> in your G4X-output directory</p> <pre><code>from pathlib import Path\nimport scanpy as sc\n\nrun_base = Path('/path/to/g4x_output/sample_x1')\nad_file = run_base / 'single_cell_data' / 'feature_matrix.h5'\n\nadata = sc.read_h5ad(ad_file)\n</code></pre> <p>Note</p> <p>If you have G4X-helpers installed, then <code>scanpy</code> will be available as one of its dependencies. If not, please refer to the scanpy documentation for installation guides.</p>"},{"location":"g4x_data/data_import/#3-building-from-raw-data","title":"3. building from raw data","text":"<p>If you do not wish to use the pre-generated <code>feature_matrix.h5</code> you can replicate a similar object by reading the counts and cell metadata into an <code>anndata</code> object.</p> <pre><code>from pathlib import Path\nimport anndata as ad\nimport pandas as pd\nfrom scipy import sparse\n\nrun_base = Path('/path/to/g4x_output/sample_x1')\n\ntxcounts_path = run_base / 'single_cell_data' / 'cell_by_transcript.csv.gz'\nmetadata_path = run_base / 'single_cell_data' / 'cell_metadata.csv.gz'\n\ncounts = pd.read_csv(txcounts_path, index_col='label')\nX = sparse.csr_matrix(counts.values)\n\nmetadata = pd.read_csv(metadata_path, index_col='label')\n\nadata = ad.AnnData(X=X, obs=metadata)\nadata.var_names = counts.columns\n</code></pre> <p>Note</p> <p>If you have G4X-helpers installed, then <code>anndata</code>, <code>pandas</code> and <code>scipy</code> will be available as dependencies.</p> <p></p>"},{"location":"g4x_data/data_import/#if-you-are-working-in-r","title":"if you are working in R","text":"<p>The most feature rich package for single-cell analysis in R is:</p> <ul> <li><code>Seurat</code>: full-featured single-cell analysis suite with spatial analysis capabilities</li> </ul> <p>To work with your data in Seurat, it needs to be loaded into a <code>SeuratObject</code>, which is an annotated data structure.</p> <pre><code>library('Seurat')\n\nrun_base = c('/path/to/g4x_output/sample_x1')\n\ntxcounts_path = file.path(run_base, \"single_cell_data/cell_by_transcript.csv.gz\")\nmetadata_path = file.path(run_base, \"single_cell_data/cell_metadata.csv.gz\")\n\ncounts &lt;- read.csv(txcounts_path, row.names = 1) \ncounts &lt;- t(counts) # transpose to match Seurat input\n\nmetadata &lt;- read.csv(metadata_path, row.names = 1) \n\nsobj &lt;- CreateSeuratObject(counts = counts, meta.data = metadata)\n</code></pre> <p>\u2e3b</p>"},{"location":"g4x_data/g4x_output/","title":"G4X-output","text":""},{"location":"g4x_data/g4x_output/#g4x-output-structure","title":"G4X-output structure","text":""},{"location":"g4x_data/g4x_output/#sample-directory-tree","title":"Sample directory tree","text":"<p>Directory structure depends on run type.</p> Transcript &amp; ProteinTranscript <pre><code>&lt;sample_root&gt;\n\u2502\n\u251c\u2500\u2500 diagnostics\n\u2502   \u2514\u2500\u2500 transcript_table.parquet\n\u2502\n\u251c\u2500\u2500 g4x_viewer \n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;.bin\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;.ome.tiff              \n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;.tar\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;_HE.ome.tiff\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;_nuclear.ome.tiff\n\u2502   \u2514\u2500\u2500 &lt;sample_1&gt;_run_metadata.json\n\u2502\n\u251c\u2500\u2500 h_and_e \n\u2502   \u251c\u2500\u2500 eosin.jp2\n\u2502   \u251c\u2500\u2500 eosin_thumbnail.png\n\u2502   \u251c\u2500\u2500 h_and_e.jp2\n\u2502   \u251c\u2500\u2500 h_and_e_thumbnail.jpg\n\u2502   \u251c\u2500\u2500 nuclear.jp2\n\u2502   \u2514\u2500\u2500 nuclear_thumbnail.png\n\u2502\n\u251c\u2500\u2500 metrics \n\u2502   \u251c\u2500\u2500 core_metrics.csv\n|   \u251c\u2500\u2500 protein_core_metrics.csv\n\u2502   \u2514\u2500\u2500 per_area_metrics.csv\n\u2502\n\u251c\u2500\u2500 protein                             \n\u2502   \u251c\u2500\u2500 &lt;protein_1&gt;.jp2\n\u2502   \u251c\u2500\u2500 &lt;protein_1&gt;_thumbnail.png\n\u2502   \u251c\u2500\u2500 &lt;protein_2&gt;.jp2\n\u2502   \u251c\u2500\u2500 &lt;protein_2&gt;_thumbnail.png\n\u2502   \u2514\u2500\u2500 \u2026\n\u2502\n\u251c\u2500\u2500 protein_panel.csv                   \n\u2502\n\u251c\u2500\u2500 rna\n\u2502   \u2514\u2500\u2500 transcript_table.csv.gz\n\u2502\n\u251c\u2500\u2500 run_meta.json\n\u2502\n\u251c\u2500\u2500 samplesheet.csv\n\u2502\n\u251c\u2500\u2500 segmentation\n\u2502   \u2514\u2500\u2500 segmentation_mask.npz\n\u2502\n\u251c\u2500\u2500 single_cell_data\n\u2502   \u251c\u2500\u2500 cell_by_protein.csv.gz          \n\u2502   \u251c\u2500\u2500 cell_by_transcript.csv.gz\n\u2502   \u251c\u2500\u2500 cell_metadata.csv.gz\n\u2502   \u251c\u2500\u2500 clustering_umap.csv.gz\n\u2502   \u251c\u2500\u2500 dgex.csv.gz\n\u2502   \u2514\u2500\u2500 feature_matrix.h5\n\u2502\n\u251c\u2500\u2500 summary_&lt;sample_1&gt;.html\n\u2514\u2500\u2500 transcript_panel.csv\n</code></pre> <pre><code>&lt;sample_root&gt;\n\u2502\n\u251c\u2500\u2500 diagnostics\n\u2502   \u2514\u2500\u2500 transcript_table.parquet\n\u2502\n\u251c\u2500\u2500 g4x_viewer\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;.bin\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;.tar\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;_HE.ome.tiff\n\u2502   \u251c\u2500\u2500 &lt;sample_1&gt;_nuclear.ome.tiff\n\u2502   \u2514\u2500\u2500 &lt;sample_1&gt;_run_metadata.json\n\u2502\n\u251c\u2500\u2500 h_and_e\n\u2502   \u251c\u2500\u2500 eosin.jp2\n\u2502   \u251c\u2500\u2500 eosin_thumbnail.png\n\u2502   \u251c\u2500\u2500 h_and_e.jp2\n\u2502   \u251c\u2500\u2500 h_and_e_thumbnail.jpg\n\u2502   \u251c\u2500\u2500 nuclear.jp2\n\u2502   \u2514\u2500\u2500 nuclear_thumbnail.png\n\u2502\n\u251c\u2500\u2500 metrics\n\u2502   \u251c\u2500\u2500 core_metrics.csv\n\u2502   \u2514\u2500\u2500 per_area_metrics.csv\n\u2502\n\u251c\u2500\u2500 rna\n\u2502   \u2514\u2500\u2500 transcript_table.csv.gz\n\u2502\n\u251c\u2500\u2500 run_meta.json\n\u2502\n\u251c\u2500\u2500 samplesheet.csv\n\u2502\n\u251c\u2500\u2500 segmentation\n\u2502   \u2514\u2500\u2500 segmentation_mask.npz\n\u2502\n\u251c\u2500\u2500 single_cell_data\n\u2502   \u251c\u2500\u2500 cell_by_transcript.csv.gz\n\u2502   \u251c\u2500\u2500 cell_metadata.csv.gz\n\u2502   \u251c\u2500\u2500 clustering_umap.csv.gz\n\u2502   \u251c\u2500\u2500 dgex.csv.gz\n\u2502   \u2514\u2500\u2500 feature_matrix.h5\n\u2502\n\u251c\u2500\u2500 summary_&lt;sample_1&gt;.html\n\u2514\u2500\u2500 transcript_panel.csv\n</code></pre> <p></p>"},{"location":"g4x_data/g4x_output/#sample-sub-directory-reference","title":"Sample sub-directory reference","text":""},{"location":"g4x_data/g4x_output/#root-of-sample_folder","title":"root of sample_folder","text":"<p><code>run_meta.json:</code> JSON file containing versioning information for the panels used and analysis pipelines as well as the ID for the sequencer on which the experiment was run.</p> <p><code>samplesheet.csv:</code> CSV file containing detailed run information. Details the experimental design, flow cell layout, tissue type, panel utilized, etc. This file is useful for analysis, as it designates where each tissue section is positioned on the flow cell.</p> <p><code>summary_&lt;sample_id&gt;.html:</code> HTML file which gives a high level overview of the experiment outputs, data quality, and performance for the selected tissue block.</p> <p><code>transcript_panel.csv:</code> CSV file containing a full list of all targeted genes in this experiment and the panel(s) which they originated from.</p> <p><code>protein_panel.csv:</code> CSV file containing a full list of all targeted proteins in this experiment and the panel(s) which they originated from. Multiomics runs only</p> <p></p>"},{"location":"g4x_data/g4x_output/#diagnostics","title":"diagnostics/","text":"<p><code>transcript_table.parquet:</code> Parquet file containing all decoded and non-decoded transcripts and associated metadata (e.g. spatial coordinate, gene identity, cell identity (if assigned to a cell), quality score, sequence). Parquet files can be loaded in Python using the polars, fastparquet, pandas, and pyarrow packages.</p> Expand to see column descriptions column type description <code>x_coord_shift</code> float The x coordinate for the transcript (shifted to global coordinates) <code>y_coord_shift</code> float The y coordinate for the transcript (shifted to global coordinates) <code>z</code> int z layer of identified transcript <code>demuxed</code> bool Whether or not the transcript was demultiplexed <code>transcript_condensed</code> str Shortened name of transcript <code>meanQS</code> float Mean quality score for the transcript <code>cell_id</code> uint Cell ID <code>sequence_to_demux</code> str Sequence identified that will be demultiplexed <code>transcript</code> str Long form transcript name (specific to single probe) <code>TXUID</code> str Unique identifier for the transcript <p> </p>"},{"location":"g4x_data/g4x_output/#g4x_viewer","title":"g4x_viewer/","text":"<p>Tip</p> <p>The G4X-viewer is a web-based tool for visualizing and exploring G4X-data. All files in this directory are designed to be loaded into and explored with the G4X-viewer. For more information on how to use the G4X-viewer, see G4X-viewer.</p> <p><code>&lt;sample_id&gt;.bin:</code> Binary file containing the segmentation mask for the stitched image. Can be easily read in Python with numpy.</p> <p><code>&lt;sample_id&gt;.ome.tiff:</code> Multidimensional OME-TIFF image file. On windows, this may appear as <code>&lt;sample_id&gt;.ome</code>. This image contains aggregated images for all protein targets as well as nuclear stain. Can be loaded into any standard ome.tiff readers, including our G4X-viewer, and napari. Multiomics runs only..</p> <p><code>&lt;sample_id&gt;_HE.ome.tiff:</code> OME-TIFF image file containing the fH&amp;E stain images. Can be loaded into any standard OME-TIFF readers, including our G4X-viewer and napari.</p> <p><code>&lt;sample_id&gt;_nuclear.ome.tiff:</code> OME-TIFF image file containing the nuclear stain images. Can be loaded into any standard OME-TIFF readers, including our G4X-viewer and napari.</p> <p><code>&lt;sample_id&gt;_run_metadata.json:</code> JSON file containing much of the same information as the run_meta.json along with extra core metrics information (such as tissue area, total tx, etc).</p> <p><code>&lt;sample_id&gt;.tar:</code> Tarball containing all other files from this directory bundled into one file. This can be loaded into the G4X-viewer directly with the \u201csingle file upload\u201d option to avoid dragging each file individually. May take longer to load than the individual files due to needing to untar the components before displaying on the Viewer.</p> <p></p>"},{"location":"g4x_data/g4x_output/#metrics","title":"metrics/","text":"<p><code>core_metrics.csv:</code> CSV file containing a set of core metrics for the tissue block including total transcripts, total area, number of cells and more.</p> <p><code>protein_core_metrics.csv:</code> CSV file containing a set of core protein metrics for the tissue block including SNR, background intensity, and Fisher's exact scores for the co-occurrence of the protein signal with its associated transcript signal (<code>&lt;protein&gt;_fisher_score</code>) and a random background (<code>&lt;protein&gt;_fisher_score_background</code>). These scores indicate the likelihood of the signal being true signal compared to the measured background. Multiomics runs only.</p> <p><code>per_area_metrics.csv:</code> CSV file containing a set of per-area metrics for the tissue block (coordinate location, number of transcripts, and number of cells), separated out into images from before the images were stitched together into one whole block.</p> <p></p>"},{"location":"g4x_data/g4x_output/#h_and_e","title":"h_and_e/","text":"<p>Tip</p> <p>The .jp2 images in this folder and the <code>/protein/</code> folder are suitable to use for both nuclear and cytoplasmic segmentation. For more information on how you might do this, see segment data.</p> <p><code>eosin.jp2:</code> Full-sized eosin stained JPEG image used for analysis purposes for selected tissue block.</p> <p><code>eosin_thumbnail.png:</code> Downsampled PNG image from the .jp2 file for easier viewing of the eosin stain for selected tissue block.</p> <p><code>h_and_e.jp2:</code> Full-sized fH&amp;E JPEG image used for analysis purposes for selected tissue block.</p> <p><code>h_and_e_thumbnail.jpg:</code> Downsampled PNG image from the .jp2 file for easier viewing of the fH&amp;E stain for selected tissue block.</p> <p><code>nuclear.jp2:</code> Full-sized nuclear stained JPEG image used for analysis purposes for selected tissue block.</p> <p><code>nuclear_thumbnail.png:</code> Downsampled PNG image from the .jp2 file for easier viewing of the nuclear stain for selected tissue block.</p> <p></p>"},{"location":"g4x_data/g4x_output/#protein-protein-runs-only","title":"protein/ (protein runs only)","text":"<p><code>&lt;protein_name&gt;.jp2:</code> Full-sized JPEG image used for analysis purposes. Shows the <code>&lt;protein_name&gt;</code> stain for selected tissue block.</p> <p><code>&lt;protein_name&gt;_thumbnail.png:</code> Downsampled PNG image of the .jp2 file for easier viewing. Shows the <code>&lt;protein_name&gt;</code> stain for selected tissue block.</p> <p></p>"},{"location":"g4x_data/g4x_output/#rna","title":"rna/","text":"<p><code>transcript_table.csv.gz:</code> CSV file containing a transcript table showing all demuxed transcripts on the whole tissue block. Contains coordinate information, z-layer, gene identity, and cell_id fields. All transcripts here are high confidence transcripts post-filtering and processing.</p> <p></p>"},{"location":"g4x_data/g4x_output/#segmentation","title":"segmentation/","text":"<p><code>segmentation_mask.npz:</code> Compressed numpy array file containing the segmentation mask. This can be easily read with the <code>numpy.load()</code> function.</p> <p></p>"},{"location":"g4x_data/g4x_output/#single_cell_data","title":"single_cell_data/","text":"<p><code>cell_by_protein.csv.gz:</code> Gzipped CSV file in a cell x protein intensity format. Each entry in the table is the average protein intensity for a given protein in a given cell. Multiomics runs only.</p> <p><code>cell_by_transcript.csv.gz:</code> Gzipped CSV file in a cell x transcript format. Each entry in the table is the counts for a given transcript in a given cell.</p> <p><code>cell_metadata.csv.gz:</code> Gzipped CSV file containing the metadata associated with each cell, including cell_id, protein mean intensity, and transcript counts per cell, per transcript species. This is needed to launch a Seurat object and perform downstream analyses. For more information, see data import.</p> Expand to see column descriptions name type description <code>label</code> str Cell ID <code>&lt;protein&gt;_intensity_mean</code> float Fluorescence intensity mean for a given protein <code>cell_id</code> str Cell ID for a given cell <code>cell_x/y</code> float Spatial X/Y coordinate for the nuclear segmentation centroid <code>expanded_cell_x/y</code> float Spatial X/Y coordinate for the expanded nuclear segmentation centroid <code>log1p_n_genes_by_counts</code> float Log number of unique genes detected <code>log1p_total_counts</code> float Log number of total transcripts <code>n_genes_by_counts</code> int Number of unique genes detected <code>nuclei_area</code> int Area of the nuclear segmentation <code>nuclei_expanded_area</code> int Area of the expanded nuclear segmentation <code>total_counts</code> int Total transcript counts <p><code>clustering_umap.csv.gz:</code> Gzipped CSV file containing the matrix of cell cluster annotations and UMAP coordinates for each cell. This is used to visualize the clustering of cells in 2D for a given leiden resolution or UMAP embedding setting.</p> Expand to see column descriptions column type description <code>label</code> str Cell ID <code>leiden_&lt;resolution&gt;</code> int Leiden cluster identity for the cell at the specified resolution (0.2-1.0) <code>X_umap_&lt;min_dist&gt;_&lt;spread&gt;_&lt;axis&gt;</code> float UMAP coordinate for the given cell with the given min_dist and spread for a given axis (1 is typically x/UMAP1, 2 is typically y/UMAP2) <p><code>dgex.csv.gz:</code> Gzipped CSV file containing the differential gene expression (DGEx) results for the selected tissue block. Columns are detailed below.</p> Expand to see column descriptions column type description <code>names</code> str Gene symbol <code>scores</code> float Z-score from Wilcoxon rank-sum test <code>logfoldchanges</code> float LogFoldChange for the given cluster compared to all other clusters combined <code>pvals</code> float P-value from Wilcoxon rank-sum test <code>pvals_adj</code> float Adjusted P-value <code>pct_nz_group</code> float Percentage of non-zero values in the given cluster. <code>pct_nz_reference</code> float Percentage of non-zero values in all cells outside the given cluster. <code>group</code> int Leiden cluster identity <code>leiden_res</code> str Leiden clustering resolution that this entry is derived from (1 per gene per cluster) <p><code>feature_matrix.h5:</code> H5ad file containing the full cell by gene matrix as well as a wide array of metadata and annotations you might want to use for downstream analysis. This file can be loaded into Python and run through scanpy or a number of other pipelines. See data import. The annotations in this file are detailed below.</p> Expand to see annotation layer descriptions name layer str dimensions description <code>&lt;protein&gt;_intensity_mean</code> float obs ncell x  1 Fluorescence intensity mean for a given protein per cell <code>cell_id</code> str obs ncell x 1 Cell ID for a given cell <code>cell_x/y</code> float obs ncell x 1 Spatial X/Y coordinate for the nuclear segmentation centroid <code>expanded_cell_x/y</code> float obs ncell x 1 Spatial X/Y coordinate for the expanded nuclear segmentation centroid per cell <code>log1p_n_genes_by_counts</code> float obs ncell x 1 Log number of unique genes detected per cell <code>log1p_total_counts</code> float obs ncell x 1 Log number of total transcripts per cell <code>n_genes_by_counts</code> int obs ncell x 1 Number of unique genes detected per cell <code>nuclei_area</code> float obs ncell x 1 Area of the nuclear segmentation per cell <code>nuclei_expanded_area</code> float obs ncell x 1 Area of the expanded nuclear segmentation per cell <code>total_counts</code> int obs ncell x 1 Total transcript counts per cell <code>gene_id</code> str var ngenes x 1 Gene symbol <code>log1p_mean_counts</code> float var ngenes x 1 Log mean transcript counts across all cells <code>log1p_total_counts</code> float var ngenes x 1 Log total transcript counts across all cells <code>mean_counts</code> float var ngenes x 1 Mean counts of each transcript across all cells <code>modality</code> str var ngenes x 1 G4X modality (transcript or protein) <code>n_cells_by_counts</code> int var ngenes x 1 Number of cells with counts of each transcript <code>pct_dropout_by_counts</code> float var ngenes x 1 Percentage of zero-count cells for each gene <code>probe_type</code> str var ngenes x 1 Type of probe: Negative control probe/sequence (NCP/NCS) or transcript targeting (targeting) <code>total_counts</code> int var ngenes x 1 Total transcript counts per gene <p></p> <p>\u2e3b</p>"},{"location":"g4x_tutorials/","title":"G4X Tutorials","text":"<p>G4X Tutorials are a collection of example workflows that demonstrate how to analyze G4X-data using popular Python and R libraries. These tutorials cover a wide range of topics, from basic visualizations to advanced analysis techniques.</p>"},{"location":"g4x_tutorials/#in-this-section-you-can","title":"In this section you can:","text":"<ul> <li>learn how to plot spatial tissue information from the G4X-data</li> <li>generate novel nuclear or cytoplasmic segmentations with popular models</li> <li>More coming soon!</li> </ul> <p>\u2e3b</p>"},{"location":"g4x_tutorials/plot_spatial/","title":"plot spatial","text":""},{"location":"g4x_tutorials/plot_spatial/#plotting-spatial-data-on-the-g4x","title":"Plotting Spatial Data on the G4X","text":"<p>One of the first things you'll want to do with your spatial data is to visualize your data on a spatial plot. G4X outputs are designed to make this information easy to access and plot in a variety of ways. With the tables and data structures provided, you can create a variety of spatial visualizations using tools like Seurat in R or scanpy in Python.</p> <p></p>"},{"location":"g4x_tutorials/plot_spatial/#python-visualization","title":"Python Visualization","text":"<p>This brief tutorial uses the scanpy library and assume that you have a working installation of it on your local system. If you do not, please see the scanpy installation guide for instructions on how to install it.</p>"},{"location":"g4x_tutorials/plot_spatial/#1-import-libraries","title":"1. Import libraries","text":"<pre><code># Import necessary libraries\nimport scanpy as sc\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#2-load-your-data","title":"2. Load your data","text":"<pre><code># Load your data\nadata = sc.read_h5ad('path/to/your/data.h5ad')\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#3-extract-spatial-coordinates-into-a-scanpy-obsm-layer-for-scanpy-compatibility","title":"3. Extract spatial coordinates into a scanpy <code>obsm</code> layer for scanpy compatibility","text":"<pre><code># Extract spatial coordinates into obsm layer\nadata.obsm['X_spatial_cell'] = adata.obs[['cell_x', 'cell_y']].to_numpy()\n</code></pre> <p>Note</p> <p>In order for scanpy to extract this information for default plotting, you have to put <code>(x, y)</code> coordinate pairs for each cell into the <code>obsm</code> layer and name it something starting with <code>X_</code>. You can do this with any pair of coordinates.</p>"},{"location":"g4x_tutorials/plot_spatial/#4-plot-the-spatial-coordinates","title":"4. Plot the spatial coordinates","text":"<pre><code># Plot the spatial coordinates\nplt.figure(figsize=(10,8))\nax = sc.pl.scatter(adata, basis='spatial_cell', color='log1p_total_counts', show=False)\n\n# Flip the y-axis to match image orientation\nax.invert_yaxis()\nplt.show()\n</code></pre> <p>Note</p> <p>Here, we're plotting with the <code>color='log1p_total_counts'</code> to visualize the log total transcript counts per cell, but you can replace this with any other variable in your <code>adata.obs</code> or <code>adata.var</code> that is the correct dimensions (1xncells) to visualize different aspects of your data.</p>"},{"location":"g4x_tutorials/plot_spatial/#5-save-the-plot-as-a-png-file","title":"5. Save the plot as a PNG file","text":"<pre><code># Save the plot as PNG\nplt.savefig(\"spatial_plot.png\", dpi=300, bbox_inches='tight')\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#r-visualization","title":"R Visualization","text":"<p>This brief tutorial uses the ggplot2 library and assumes that you have a working installation of it on your local system. If you do not, please see the ggplot2 installation guide for instructions on how to install it.</p>"},{"location":"g4x_tutorials/plot_spatial/#1-load-necessary-libraries","title":"1. Load necessary libraries","text":"<pre><code># Load necessary libraries\nlibrary(ggplot2)\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#2-load-your-data-and-create-a-seurat-object","title":"2. Load your data and create a Seurat object","text":"<pre><code># Load your data and create a Seurat object\nrun_base = c('/path/to/g4x_output/&lt;sample_id&gt;')\nmetadata_path = file.path(run_base, \"single_cell_data/cell_metadata.csv.gz\")\nmeta &lt;- read.csv(gzfile(metadata_path), row.names = 1)\n</code></pre>"},{"location":"g4x_tutorials/plot_spatial/#3-plot-spatial-coordinates-with-ggplot2","title":"3. Plot spatial coordinates with ggplot2","text":"<pre><code># Ensure coordinates are numeric\nmeta$cell_x &lt;- as.numeric(meta$cell_x)\nmeta$cell_y &lt;- as.numeric(meta$cell_y)\n\np &lt;- ggplot(meta, aes(x = cell_x, y = cell_y, color=log1p_total_counts)) +\n  geom_point(size = 0.3, alpha = 0.6) +\n  scale_y_reverse() +           # &lt;-- invert Y\n  coord_equal() +\n  labs(x = \"cell_x\", y = \"cell_y\", color = \"log1p(total_counts)\") +\n  theme_minimal()\n\nprint(p)\n</code></pre> <p>Note</p> <p>Here, we're plotting with the <code>color='log1p_total_counts'</code> to visualize the log total transcript counts per cell, but you can replace this with any other variable in your <code>meta</code> dataframe that is the correct dimensions (1xncells) to visualize different aspects of your data.</p>"},{"location":"g4x_tutorials/plot_spatial/#4-save-the-plot-as-a-png-file","title":"4. Save the plot as a PNG file","text":"<p><pre><code># Save as Plot as PNG\nggplot2::ggsave(\n  filename = \"cell_xy_log1p_total_counts.png\",\n  plot     = p,\n  width    = 8, height = 8, dpi = 300, units = \"in\",\n  bg       = \"white\"   \n)\n</code></pre> </p> <p>\u2e3b</p>"},{"location":"g4x_tutorials/segment_data/","title":"segment data","text":""},{"location":"g4x_tutorials/segment_data/#segmenting-g4x-data","title":"Segmenting G4X-data","text":"<p>Here, we lay out a basic approach to resegment your G4X-data. We strongly encourage you to start this process by looking at the existing segmentation using our G4X-viewer. This will allow you to identify where it fails to capture your desired cell morphology. </p> <p>These instructions are designed to help you take the .jp2 images described in the G4X-data output documentation and run your own segmentation using Cellpose 2. This is typically an iterative process.</p>"},{"location":"g4x_tutorials/segment_data/#_1","title":"segment data","text":""},{"location":"g4x_tutorials/segment_data/#basic-segmentation-approach","title":"Basic segmentation approach","text":"<p>For this tutorial, we use the most basic Cellpose arguments. It is strongly encouraged that you look into the Cellpose documentation for more advanced options that may suit your needs.</p>"},{"location":"g4x_tutorials/segment_data/#1-import-libraries","title":"1. Import libraries","text":"<p><pre><code>import numpy as np\nimport glymur\nfrom cellpose import models\nfrom cellpose.models import CellposeModel\nfrom skimage.exposure import rescale_intensity\n</code></pre> </p>"},{"location":"g4x_tutorials/segment_data/#2-choose-which-type-of-segmentation-you-want-to-run","title":"2. Choose which type of segmentation you want to run","text":"Nuclear OnlyNuclear +1 markerNuclear +2 markers"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-image-using-glymur","title":"3. Load the .jp2 image using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-your-nuclear-image-to-the-range-0-1","title":"4. Normalize your nuclear image to the range 0-1","text":"<pre><code># --- Normalize nuclear image ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-run-nuclear-segmentation","title":"5. Run nuclear segmentation","text":"<pre><code># --- Run nuclear model ---\nmodel = models.CellposeModel(gpu=True, model_type=\"nuclear\")\nmasks, flows, styles = model.eval(nuclear_norm_subset, channels=[0],\n                                    normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-images-using-glymur","title":"3. Load the .jp2 images using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\nmarker1 = glymur.Jp2k(\"path/to/marker1.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-each-image-channel-to-the-range-0-1","title":"4. Normalize each image channel to the range 0-1","text":"<pre><code># --- Normalize each channel separately ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\nmarker1_norm = rescale_intensity(marker1, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-stack-your-channels-for-cellpose-input","title":"5. Stack your channels for Cellpose input","text":"<pre><code># --- Stack channels:  marker1_norm = channel 0, nuclear = channel 1 ---\ninput_img = np.stack([marker1_norm, nuclear_norm], axis=2)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#6-run-cyto3-segmentation","title":"6. Run Cyto3 segmentation","text":"<pre><code># --- Run Cyto3 ---\nmodel = models.Cellpose(gpu=True, model_type=\"cyto3\")\nmasks, flows, styles, diams = model.eval(input_img, channels=[1, 0], \n                                            normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#3-load-the-jp2-images-using-glymur_1","title":"3. Load the .jp2 images using glymur","text":"<pre><code># --- Load JP2 Images ---\nnuclear = glymur.Jp2k(\"path/to/nuclear.jp2\")[:]\nmarker1 = glymur.Jp2k(\"path/to/marker1.jp2\")[:]\nmarker2 = glymur.Jp2k(\"path/to/marker2.jp2\")[:]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#4-normalize-each-image-channel-to-the-range-0-1_1","title":"4. Normalize each image channel to the range 0-1","text":"<pre><code># --- Normalize each channel separately ---\nnuclear_norm = rescale_intensity(nuclear, out_range=(0, 1))\nmarker1_norm = rescale_intensity(marker1, out_range=(0, 1))\nmarker2_norm = rescale_intensity(marker2, out_range=(0, 1))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#5-perform-averaging-of-markers-to-create-a-combined-membrane-channel","title":"5. Perform averaging of markers to create a combined membrane channel","text":"Simple AverageWeighted Average <pre><code># combine membrane markers\nmembrane_combo = (marker1_norm + marker2_norm) / 2  # simple average\n</code></pre> <pre><code># weighted average (sum of weights should be 1)\nmarker1_weight = 0.35\nmarker2_weight = 0.65\nmembrane_combo = ((marker1_weight * marker1_norm) + \n                    (marker2_weight * marker2_norm))\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#6-stack-your-channels-for-cellpose-input","title":"6. Stack your channels for Cellpose input","text":"<pre><code># --- Stack channels:  membrane = channel 0, nuclear = channel 1 ---\ninput_img = np.stack([membrane_combo, nuclear_norm], axis=2)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#7-run-cyto3-segmentation","title":"7. Run Cyto3 segmentation","text":"<pre><code># --- Run Cyto3 ---\nmodel = models.Cellpose(gpu=True, model_type=\"cyto3\")\nmasks, flows, styles, diams = model.eval(input_img, channels=[1, 0], \n                                            normalize=False)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#iterating-on-your-segmentation","title":"Iterating on your segmentation","text":"<p>After you've generated your segmentation masks, you sould take time to visualize them and determine if they are meeting your needs. This is an iterative process that may take several rounds of tuning. </p> <p>To save time, you may want to consider using some basic python plotting as well as subsetting your data to speed up iteration. Below are examples of each.</p> <p></p>"},{"location":"g4x_tutorials/segment_data/#visualize-your-segmentation","title":"Visualize your segmentation","text":"<p>Here is a snippet of code to visualize your segmentation masks overlaid on a single fluorescent image. Notably, the variable this uses are:</p> <ul> <li><code>marker_image</code>: a single fluorescent image (e.g. nuclear or membrane) to show the cell outlines against (same dimensions as <code>masks</code>)</li> <li><code>masks</code>: the generated segmentation masks from Cellpose</li> </ul> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8,8))\n\n# Show the fluorescent image in blue with a bit of transparency\nvmax = np.percentile(marker_image, 99) # remove hot pixels\nplt.imshow(\n    marker_image, \n    cmap=\"Blues\", vmin=0, vmax=vmax, alpha=0.8, origin=\"lower\"\n)\n\n# Draw one contour around each labeled cell\n# using half-integer levels to outline integer labels cleanly\nlevels = np.arange(0.5, masks.max() + 0.5, 1.0)\nplt.contour(masks, levels=levels, colors=\"gray\", \n                linewidths=0.7, origin=\"lower\") \n\nplt.axis(\"off\")\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p>"},{"location":"g4x_tutorials/segment_data/#subset-your-images","title":"Subset your images","text":"<p>Since this process can take quite a while on our stitched images, you may want to try to hone your approach first on a smaller, cropped image. For example, after loading your .jp2 image(s), you can subset them with something like this, running your segmentation on that block only:</p> <pre><code>sz = 1000 # max size of your subset block\n\n# get the image size\nx = marker_norm.shape[0]\ny = marker_norm.shape[1]\n\n# take the middle 1000 x 1000 pixel block\nmarker_subset = marker_norm[int((y/2)-int(sz/2)):int((y/2)+int(sz/2)),\n                            int((x/2)-int(sz/2)):int((x/2)+int(sz/2))]\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#applying-your-segmentation","title":"Applying your segmentation","text":"<p>Once you are happy with the outputs, you are ready to save them and run our G4X-helpers tool to regenerate your single cell data using your new segmentation masks.</p>"},{"location":"g4x_tutorials/segment_data/#save-your-segmentation-masks","title":"Save your segmentation masks","text":"<pre><code># ---- Save generated masks ----\nnp.save(\"/path/to/output/folder/resegmented_masks.npy\", masks)\nnp.savez_compressed(\"/path/to/output/folder/resegmented_masks.npz\", \n                    nuclei=masks, nuclei_exp=masks)\n</code></pre>"},{"location":"g4x_tutorials/segment_data/#regenerate-your-g4x-outputs","title":"Regenerate your G4X outputs","text":"<p>After you have a segmentation that you are happy with, use out resegmentation tool to regenerate it for each tissue block. For installation tips, see our guide on installing G4X-helpers. For advanced usage tips, see our resegment documentation.</p> <pre><code>resegment \n    --run_base /path/to/data/dir/&lt;block_id&gt;\n    --segmentation_mask /path/to/new/masks.npy \n    --out_dir /path/to/output/dir/\n</code></pre> <p></p> <p>\u2e3b</p>"}]}